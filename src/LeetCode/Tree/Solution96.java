package LeetCode.Tree;

/**
 * 不同的二叉搜索树：给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
 * 分析：在草稿纸上画了当n=2,3,4时的情况，画n=4时发现了好像是在n=3的情况里变换，从而想到了可能
 * 是动态规划，但是不知道怎么由n得到n+1的情况即不知道状态该怎么转移，而且好像有些树也不能直接通过n-1
 * 的情形得到，所以放弃了动态规划。继续分析，发现对于每个输入n，从1到n的每个数都可以作为二叉搜索树的
 * 根节点，但是不同的根节点对应的二叉搜索树数目不相同，没啥规律，所以又放弃了，看了官方题解
 */
public class Solution96 {
    /*
    法一：动态规划。其实我上面想到的这些已经差不多了！但是我没有用公式去列出来，从而发现规律。
    直觉没有错，n对应的二叉搜索树的数目的确和n-1是有关的，只是这个状态转移不是那么直接和简单。
    需要列公式去发现，假设G(i)表示i个整数对应的二叉搜索树的数目，F(j, i)表示其中以j(1<=j<=i)
    为根节点的二叉搜索树的数目，那么明显G(i)等于sum(F(j,i))(1<=j<=i)，sum表示求和。接下来
    再看看F(j,i)，对于以j为节点的二叉搜索树，它的左子树由1...j-1这j-1个数构成，右子树由j+1
    ...i这i-j个数构成，即F(j,i)=G(j-1)*G(i-j)!即F(j,i)是是左右子树个数的笛卡尔积！综上，
    有G(i) = sum(G(j-1)*G(i-j)) (1<=j<=i)。举个例子，G(3)=G(0)*G(2)+G(1)*G(1)+G(2)*G(0)
    分别表示以1,2,3为根节点时的二叉搜索树的数目。因为求G(i)要用到G(0)-G(i-1)，所以应该是先求子问题
    的解，即从小到大求，有了公式实现代码就简单了。（详细分析过程可参考官方题解，非常清楚）
    时间复杂度为O(N^2)，空间复杂度为O(N)
     */
    public static int numTrees(int n) {
        if (n < 0){
            return 0;
        }
        // G[i]长度为i的序列能构成的二叉搜索树的数量，即由序列1-i构成的二叉搜索树的数量
        int[] G = new int[n + 1];
        // 初始化
        G[0] = 1;
        G[1] = 1;
        // 填表
        for (int i = 2; i <= n; i++){
            // 求G[i]，1-i序列中的每个数都可以作为根节点
            for (int j = 1; j <= i; j++){
                G[i] += G[j - 1] * G[i - j];
            }
        }
        return G[n];
    }

    /*
    法二：数学法，其实这里的G(i)就是数学中的卡塔兰数，卡塔兰数的计算公式为（见官方题解）：
    G(0)=1, G(i+1)=2(2i+1)/(i+2) * G(i)（其实我后面就觉得这是一道数学题，但是不知道
    怎么计算G(i)，btw这公式谁知道啊，知道了叶记不住啊...）
    时间复杂度为O(N)，空间复杂度为O(1)
     */
    public int numTrees2(int n) {
        if (n < 0){
            return 0;
        }
        // 坑，这里要用long类型, 不然会溢出
        long C = 1;
        for (int i = 0; i < n ;i++){ // 注意这里是0<=i<n，不是1<=j<=n-1，因为i本身参与了计算
            C = 2 * C * (2 * i + 1) / (i + 2);
        }
        return (int) C;
    }

    public static void main(String[] args){
        int numOfBST = numTrees(3);
        System.out.println(numOfBST);
    }
}

