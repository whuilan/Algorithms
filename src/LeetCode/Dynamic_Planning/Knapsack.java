package LeetCode.Dynamic_Planning;

/**
 * 0-1背包问题：给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。
 * 其中第i个物品的重量为 w[i]，价值为 v[i]，现在让你用这个背包装物品，最多能装的价值是多少？
 * 分析：
 * 1 确定变量
 * “动态”很明显，就是一步步地选择物品然后装进背包，选择一个物品之后，承重量会减小，能选择的物品
 * 也会发生改变（如果上一步选了，这一步就不能选这个物品了），因此原问题和子问题中有两个变量，即背包容量
 * 和可选择的物品，也就是这两个可以来描述“一般化”的问题：确定物品的种类（重量和价值）和一个背包的容量就
 * 形成了一个背包问题。
 * 2 根据变量确定状态dp数组的含义
 * 用dp[i][j]来表示对于前i个物品，当给定容量为j时，能装下的物品的最大价值，即前i件物品中选择若干件放在承重
 * 为j的背包中，可以取得的最大价值（其实dp[i][j]也可以理解为当背包容量为j时依次挑选物品，经过第i个物品时能够
 * 装的最大价值。）
 * 3 明确选择，即分类讨论：
 * 对于每件物品，都有两个选择：装或者不装
 * 4 得出状态转移方程
 * 在所有选择里面得出最优解，对于一个确定的dp[i][j]，当前物品为i时，如果选择装，说明留给前面i-1个物品的体积
 * 只能是j-w[i],这个子问题的最优解为dp[i-1][j-w[i]]+v[i]，如果不装，那么全部的j都可以用来装i-1，即
 * dp[i-1][j]，选取二者中较大的，当然，如果w[i]比j大,根本装不下，那也不用选是装还是不装了。综上，状态转移
 * 方程为：
 * dp[i][j] = dp[i-1][j], w[i] > j
 * dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]), w[i] <= w
 * 延伸/变形问题：416分割等和子集
 * 完全背包见518 零钱兑换II
 */
public class Knapsack {
    public int knapsack(int W, int N, int[] w, int[] v){
        // 输入检测省略
        // 1.创建dp数组，加1是为了方便直接用dp[N][W]来表示结果
        int[][] dp = new int[N+1][W+1];
        // 2.初始过程就是dp[0][..] = 0 和 dp[..][0] = 0即物品数量为0或容量为0时，返回0。
        // 数组默认值就是0，因此可以省略初始化代码
        // 3.填表：遍历所有状态变量，在所有选择中选择最优的。
        for (int i = 1; i <= N; i++){
            for (int j = 1; j <= W; j++){
                // 注意索引问题，i,j是从1开始的，第i个物品对应的重量和价值应该是w[i-1]、v[i-1]
                // 但只是取重量和价值时需要减1，dp[i][j]的含义及状态转移是不应该改变的
                if (w[i-1] > j){
                    dp[i][j] = dp[i-1][j];
                }else {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w[i-1]]+v[i-1]);
                }
            }
        }
        return dp[N][W];
    }
}
