package LeetCode.Dynamic_Planning;

/**
 * 整数拆分：给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。
 * 返回你可以获得的最大乘积。（其实就是剑指14题 剪绳子）
 * 分析：这个题和322零钱兑换非常相似，基本一样。首先求的是最值，那么很有可能是动态规划。
 * 如果是动态规划，那么分析“动态”的过程是什么，也就是所求的大问题的子问题是什么？显然就是
 * 不断地从整数中拆分出一个数，使得整数越来越小，这个过程中的变量是整数的大小，因此可以把【状态】
 * 设置为整数大小为i时能得到的最大乘积（状态=变量+题目问的什么），即构造以为数组dp.接着来分析状态
 * 转移方程是什么？这就是动态规划中的”规划“二字了，其实代表”做选择“，我们进行每一步都面临着若干选择
 * 比如我们拆第一个数的时候，就有n-1种选择，可以选择拆分出1，2...n-1。但是我们事先不知道拆分几才能
 * 使各个项的乘积最大，所以要把所有的可能都尝试一遍，然后比较它们各自的结果，选取最大的情况。即：
 * dp[i] = max(dp[j]*dp[i-j])(1<j<i)，这样就得到状态转移方程啦！剩下的就是(从下往上)填表啦！
 * 注意：这个题有点坑的地方使要求n>1，且至少要拆分一次。也就是说如果n<=1,返回0.如果n=2，返回1；
 * 如果n=3,返回2。但是当n>3的时候，我们根据上面的状态转移方程填表的时候，拆分出2或3时，这个项最大
 * 的积就是它们自身，也就是2或3，因为至少已经拆分过一次了。不用在像单独的只有2或3时再拆分一次。
 * 因此当n<4时，需要先单独返回。
 * 时间复杂度为O(n^2)（双层循环），空间复杂度为O(n).
 * 还可以用贪婪算法见剑指14法二
 * */
public class Solution343 {
    public int integerBreak(int n) {
        if(n <= 1){
            return 0;
        }
        if(n == 2){
            return 1;
        }
        if(n == 3){
            return 2;
        }
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2; // 其他的默认为0，包括dp[0]
        dp[3] = 3;
        for(int i = 4; i <= n; i++){
            for(int j = 1; j <= i / 2; j++){
                dp[i] = Math.max(dp[i], dp[j]*dp[i-j]);
            }
        }
        return dp[n];
    }
}
